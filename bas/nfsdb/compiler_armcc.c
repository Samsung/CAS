#include <signal.h>
#include <poll.h>
#include <wait.h>
#include <dirent.h>
#include "compiler.h"

DEFINE_COMPILER_OBJECT(armcc);

DEFINE_COMPILER_REPR(armcc) {

	static char repr[128];
	snprintf(repr,128,"<armcc compiler object at %lx",(uintptr_t)self);
	return PyUnicode_FromString(repr);
}

/* Having tmpDirPath with a list of .lst files generated by armcc extract names of compiled files
 * Return the Python list of names of compiled files
 */
static PyObject* getArmccCompiledFiles(PyObject* tmpDirPath) {

    DIR *d;
    struct dirent *dir;
    static char line[8192];
    PyObject* names = PyList_New(0);
    d = opendir(PyString_get_c_str(tmpDirPath));
    if (!d) goto Done;
    const char* curr_dir = getcwd(0,0);
    if (!curr_dir) goto Done;
    int r = chdir(PyString_get_c_str(tmpDirPath));
    if (r<0) goto Done;
    while ((dir = readdir(d)) != NULL) {
        if (dir->d_type == DT_REG) {
            if (!strcmp(get_filename_ext(dir->d_name),"lst")) {
                FILE *fp = fopen(dir->d_name, "r");
                if (!fp) continue;
                const char* first_line = fgets(line, sizeof (line), fp);
                if (!first_line) {
                    fclose(fp);
                    continue;
                }
                const char* quote_start = strchr(first_line,'"');
                const char* quote_end = strrchr(first_line,'"');
                PyList_Append(names,PyUnicode_FromStringAndSize(quote_start+1,quote_end - quote_start - 1));
                fclose(fp);
            }
        }
    }
    closedir(d);
    r = chdir(curr_dir);
    free((void*)curr_dir);
    assert(r==0 && "Cannot chdir() back to original directory");
Done:
    return names;
}

/* Having tmpDirPath with a list of .lst files generated by armcc return the contents of all the .lst files in Python list
 * Skip .lst files generated for assembling .s files (so far we rely only on the extension of compiled file)
 */
static PyObject* getArmccFiles(PyObject* tmpDirPath) {

    DIR *d;
    struct dirent *dir;
    PyObject* contents = PyList_New(0);
    d = opendir(PyString_get_c_str(tmpDirPath));
    if (!d) goto Done;
    const char* curr_dir = getcwd(0,0);
    if (!curr_dir) goto Done;
    int r = chdir(PyString_get_c_str(tmpDirPath));
    if (r<0) goto Done;
    while ((dir = readdir(d)) != NULL) {
        if (dir->d_type == DT_REG) {
            if (!strcmp(get_filename_ext(dir->d_name),"lst")) {
                FILE *f = fopen(dir->d_name, "rb");
                if (!f) continue;
                fseek(f, 0, SEEK_END);
                long fsize = ftell(f);
                fclose(f);
                char *string = malloc(fsize + 1);
                char* p = string;
                f = fopen(dir->d_name, "r");
                if (!f) continue;
                char * line = 0;
                size_t len = 0;
                ssize_t read;
                int first = 1;
                while ((read = getline(&line, &len, f)) != -1) {
                    if ((read>0) && (first)) {
                        memcpy(p,line,read);
                        p+=read;
                        first = 0;
                        if ((read>=4) && (line[read-4]=='.') && (line[read-3]=='s')) {
                            fclose(f);
                            if (line) free(line);
                            free(string);
                            goto outer_next;
                        }
                    }
                    else if ((read>0) && (line[0]=='L')) {
                        memcpy(p,line,read);
                        p+=read;
                    }
                }
                *p = 0;
                fclose(f);
                if (line) free(line);
                PyList_Append(contents,PyUnicode_FromString(string));
                free(string);
            }
        }
outer_next:
        ;
    }
    closedir(d);
    r = chdir(curr_dir);
    free((void*)curr_dir);
    assert(r==0 && "Cannot chdir() back to original directory");
Done:
    return contents;
}

/* TODO: this code would appreciate some refactoring (and maybe even some testing!) */
DEFINE_COMPILER_GET_COMPILATIONS(armcc) {

    /*
     * get_compilations(self,args,kwargs) {...}
     *
     *  armcc.get_compilations([ (bin, CWD, hcmd, icmd), ... ],jobs)
     */

    PyObject* comps = PyTuple_GetItem(args,0);
    int jobs = (int)PyLong_AsLong(PyTuple_GetItem(args,1));
    PyObject* argv = PyDict_New();

    DBG(self->debug,"--- libetrace_compiler_armcc_get_compilations(%ld,%d)\n",PyList_Size(comps),jobs);

    if (PyList_Size(comps)<=0) {
        return argv;
    }

    DIR* dir = opendir("/tmp/ARMCC");
    if ((!dir) && (ENOENT == errno)) {
        int status = mkdir("/tmp/ARMCC",S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
        if (status<0) {
            DBG(self->debug,"--- libetrace_compiler_armcc_get_compilations(): cannot create tmp directory (/tmp/ARMCC)\n");
            return argv;
        }
    }

	if (self->debug_compilations) {
		Py_ssize_t i;
		for (i=0; i<PyList_Size(comps); ++i) {
			PyObject* comp = PyList_GetItem(comps,i);
			printf("# %s\n\n",REPR(comp));
		}
	}

    struct sigaction act;
    act.sa_handler = intHandler;
    sigaction(SIGINT, &act, 0);
    interrupt = 0;

    struct pollfd* pfds = calloc(sizeof(struct pollfd),jobs);
    int u;
    for (u=0; u<jobs; ++u) pfds[u].fd = -1;
    struct job* pjob = calloc(sizeof(struct job),jobs);
    Py_ssize_t proc_index=0, comp_index=0;
    int job_num = 0;
    Py_ssize_t comp_num = PyList_Size(comps);
    progress_max_g = comp_num;
    progress_g = 0;
    update_progress(comp_index);
    DBG(self->debug_compilations, " *** comp_num: %ld\n",comp_num);
    while((job_num<jobs) && (comp_index<comp_num)) {
        update_progress(comp_index);
        PyObject* comp = PyList_GetItem(comps,comp_index);
        const char* bin = PyString_get_c_str(PyTuple_GetItem(comp,0));
        const char* cwd = PyString_get_c_str(PyTuple_GetItem(comp,1));
        PyObject* original_args = PyTuple_GetItem(comp,2);
        if (PyList_Size(original_args)<=1) {
            comp_index++;
            continue;
        }
        if (PySequence_Contains(original_args,Py_BuildValue("s","-M"))>0) {
            comp_index++;
            continue;
        }
        PyObject* bargs = PyList_GetSlice(original_args,0,PyList_Size(original_args));
        /* Spawn the process for generating .lst files */
        int match = 0;
        Py_ssize_t i = PySequence_Contains_Prefix(bargs,Py_BuildValue("s","-o"),&match);
        if (i>=0) {
            PySequence_DelItem(bargs, i);
            if (match) {
                PySequence_DelItem(bargs, i);
            }
        }
        if (!PySequence_Contains(bargs,Py_BuildValue("s","--list"))) {
            PyList_Append(bargs,Py_BuildValue("s","--list"));
        }
        if ((!PySequence_Contains(bargs,Py_BuildValue("s","-P"))) && (!PySequence_Contains(bargs,Py_BuildValue("s","-E")))) {
            PyList_Append(bargs,Py_BuildValue("s","-P"));
        }
        i = PySequence_Contains_Prefix(bargs,Py_BuildValue("s","--list_dir"),&match);
        char tmpname[] = "/tmp/ARMCC/armcc-tmp.XXXXXX";
        char *tmp_dirname = mkdtemp (tmpname);
        DBG(self->debug_compilations,"TMP: %s\n",tmp_dirname);
        if (tmp_dirname) {
            char lstdname[11+28];
            snprintf(lstdname,39,"--list_dir=%s",tmp_dirname);
            if (i>=0) {
                PySequence_DelItem(bargs, i);
                if (match) {
                    PySequence_DelItem(bargs, i);
                }
            }
            PyList_Append(bargs,Py_BuildValue("s",lstdname));
        }
        PyList_SetItem(bargs,0,Py_BuildValue("s",bin));
        DBG(0,"@%s [%s] %s\n",bin,cwd,REPR(bargs));
        int pid = run_child(bin,cwd,bargs,&pfds[proc_index].fd,0);
        DBG(self->debug_compilations,"# OR. [%d] %s@%s [%s]\n\n",pid,cwd,bin,STRJOIN(original_args));
        DBG(self->debug_compilations,"# EX. [%d] %s@%s [%s]\n\n",pid,cwd,bin,STRJOIN(bargs));
        Py_DecRef(bargs);
        if (pid>0) {
            DBG(self->debug_compilations, " *** %d created [%s](lst)\n",pid,bin);
            pfds[proc_index].events = POLLIN|POLLHUP;
            pjob[proc_index].index = comp_index;
            pjob[proc_index].pid = pid;
            buffer_init(&pjob[proc_index].buff,4096);
            pjob[proc_index].pfd = &pfds[proc_index];
            pjob[proc_index].comp = comp;
            pjob[proc_index].input = 0;
            pjob[proc_index].fns = Py_BuildValue("s",tmpname);
            proc_index++;
            job_num++;
        }
        else {
            DBG(self->debug_compilations, " *** Failed to create child: [%s](lst): %d\n",bin,errno);
        }
        comp_index++;
    }

    int initial_job_num = job_num;
    while ((job_num)||(comp_index<PyList_Size(comps))) {

        int status;
        if (interrupt) {
            for (u=0; u<jobs; ++u) {
                if (pfds[u].fd!=-1) {
                    int r = waitpid(pjob[u].pid,&status,0);
                    if (r<0) DBG(1, " *** waitpid(%d): %d (%d)\n",pjob[u].pid,r,(r<0)?errno:0);
                    if (r>0) {
                        if (status!=0) DBG(0,"wait status: %d (%d)\n",status,WIFEXITED(status));
                        if (WIFEXITED(status)) {
                            pjob[u].pid = 0;
                            close(pfds[u].fd);
                            pfds[u].fd = -1;
                        }
                    }
                }
            }
            printf("\n");
            Py_DecRef(argv);
            argv = PyDict_New();
            goto done;
        }

        update_progress(comp_index);
        if (job_num) {
            poll(pfds,jobs,-1);
            for (u=0; u<jobs; ++u) {
                if (pfds[u].fd!=-1) {
                    if( pfds[u].revents & (POLLIN|POLLHUP) ) {
                        struct job* job = pjob+u;
                        buffer_alloc(&job->buff,4096);
                        ssize_t count = read(pfds[u].fd, job->buff.data+job->buff.size, 4096);
                        if (count == -1) {
                            if (errno != EINTR) {
                                /* Mark the fd as invalid and try to wait the child */
                                DBG(self->debug_compilations, " *** Error on read at %d (pid: %d): %d\n",pfds[u].fd,pjob[u].pid,errno);
                                close(pfds[u].fd);
                                pfds[u].fd = -1;
                                waitpid(pjob[u].pid,&status,WNOHANG);
                            }
                        }
                        else if (count==0) {
                            /* hit EOF; reap the child */
                            int r = waitpid(pjob[u].pid,&status,WNOHANG);
                            if (r<0) DBG(2, " *** waitpid(%d): %d (%d)\n",pjob[u].pid,r,(r<0)?errno:0);
                            if (r>0) {
                                if (status!=0) {
                                    DBG(1,"wait status: %d (%d)\n",status,WIFEXITED(status));
                                    DBG(self->debug_compilations,"wait status: %d (%d) @[%d](%d)\n",status,WIFEXITED(status),pjob[u].pid,pjob[u].index);
                                    DBG(self->debug_compilations,"%s\n",PyString_get_c_str(PyUnicode_FromStringAndSize(
                                            (const char*)pjob[u].buff.data,buffer_size(&pjob[u].buff))));
                                    DBG(!self->debug_compilations,"wait status: %d (%d)[%d]\n",status,WIFEXITED(status),pjob[u].index);
                                    PyObject* comp = PyList_GetItem(comps,pjob[u].index);
                                    const char* bin = PyString_get_c_str(PyTuple_GetItem(comp,0));
                                    const char* cwd = PyString_get_c_str(PyTuple_GetItem(comp,1));
                                    PyObject* original_args = PyTuple_GetItem(comp,2);
                                    DBG(1,"%s [%s] %s\n",bin,cwd,REPR(original_args));
                                }
                                if (WIFEXITED(status)) {
                                    DBG(self->debug_compilations, " *** %d exited\n",pjob[u].pid);
                                    pjob[u].pid = 0;
                                    close(pfds[u].fd);
                                    pfds[u].fd = -1;
                                    DBG(self->debug_compilations,"@@@[%s]:(%d)\n",
                                            REPR(PyUnicode_FromStringAndSize((const char*)pjob[u].buff.data,buffer_size(&pjob[u].buff))),pjob[u].index);
                                    if (!pjob[u].input) {
                                        // Spawn process to read macro definitions */
                                        DBG(self->debug_compilations, " *** spawn for macro\n");

                                        PyObject* comp = pjob[u].comp;
                                        const char* bin = PyString_get_c_str(PyTuple_GetItem(comp,0));
                                        const char* cwd = PyString_get_c_str(PyTuple_GetItem(comp,1));
                                        PyObject* original_args = PyTuple_GetItem(comp,2);
                                        PyObject* bargs = PyList_GetSlice(original_args,0,PyList_Size(original_args));

                                        PyObject* istr = Py_BuildValue("s","--preinclude");
                                        Py_ssize_t i;
                                        int match;
                                        do {
                                            i = PySequence_Contains_Prefix(bargs,istr,&match);
                                            if (i>=0) {
                                                PySequence_DelItem(bargs, i);
                                                if (match) {
                                                    PySequence_DelItem(bargs, i);
                                                }
                                            }
                                        } while(i>=0);
                                        i = PySequence_Contains_Prefix(bargs,Py_BuildValue("s","-o"),&match);
                                        if (i>=0) {
                                            PySequence_DelItem(bargs, i);
                                            if (match) {
                                                PySequence_DelItem(bargs, i);
                                            }
                                        }
                                        PyList_Insert(bargs,1,Py_BuildValue("s","--list_macros"));
                                        PyList_Insert(bargs,1,Py_BuildValue("s","-P"));
                                        PyList_Insert(bargs,1,Py_BuildValue("s","-E"));
                                        i = PySequence_Contains_Prefix(bargs,Py_BuildValue("s","-c"),&match);
                                        if ((i<0) || (!match)) {
                                            PyList_Insert(bargs,1,Py_BuildValue("s","-c"));
                                        }
                                        DBG(0,"@%s [%s] %s\n",bin,cwd,REPR(bargs));
                                        PyObject* fns = getArmccCompiledFiles(pjob[u].fns);
                                        DBG(0,"%s : %s\n",REPR(fns),REPR(pjob[u].fns));
                                        for (i=0; i<PyList_Size(fns); ++i) {
                                            if (PySequence_Contains(bargs,PyList_GetItem(fns,i))) {
                                                Py_ssize_t j = PySequence_Index(bargs,PyList_GetItem(fns,i));
                                                PySequence_DelItem(bargs,j);
                                            }
                                        }
                                        DBG(0,"@%s [%s] %s\n",bin,cwd,REPR(bargs));

                                        PyList_Append(bargs,Py_BuildValue("s","-"));
                                        PyList_SetItem(bargs,0,Py_BuildValue("s",bin));
                                        int pid = run_child(bin,cwd,bargs,&pfds[u].fd,1);
                                        DBG(self->debug_compilations,"# OR. [%d] %s@%s [%s]\n\n",pid,cwd,bin,STRJOIN(original_args));
                                        DBG(self->debug_compilations,"# EX. [%d] %s@%s [%s]\n\n",pid,cwd,bin,STRJOIN(bargs));
                                        Py_DecRef(bargs);
                                        if (pid>0) {
                                            DBG(self->debug_compilations, " *** %d created [%s](mcmd)\n",pid,bin);
                                            pfds[u].events = POLLIN|POLLHUP;
                                            pjob[u].pid = pid;
                                            buffer_clear(&pjob[u].buff);
                                            pjob[u].pfd = &pfds[u];
                                            pjob[u].input = 1;
                                            job_num++;
                                        }
                                        else {
                                            DBG(self->debug_compilations, " *** Failed to create child: [%s](mcmd): %d\n",bin,errno);
                                        }
                                    }
                                    else {
                                        DBG(self->debug_compilations, " *** parse macro defs\n");

                                        PyObject* im = PyUnicode_FromStringAndSize((const char*)pjob[u].buff.data,buffer_size(&pjob[u].buff));
                                        PyObject* files = getArmccFiles(pjob[u].fns);
                                        rmrf((char*)PyString_get_c_str(pjob[u].fns));
                                        if (PyList_Size(files)>0) {
                                            PyObject* vt = PyTuple_New(2);
                                            PyTuple_SetItem(vt,0,files);
                                            PyTuple_SetItem(vt,1,im);
                                            PyDict_SetItem(argv,Py_BuildValue("i",pjob[u].index),vt);
                                        }
                                    }
                                    job_num--;
                                } /* EXITED */
                            } /* waitpid success */
                        } /* EOF */
                        else {
                            buffer_advance(&job->buff,count);
                        }
                    } /* fd IN */
                } /* fd present */
            } /* for all slots */
        } /* job_num > 0 */

        /* Spawn new child (if more children is waiting in the queue) */
        if ((comp_index<PyList_Size(comps))&&(job_num<jobs)) {
            /* Find empty slot */
            for (u=0; u<jobs; ++u) {
                if (pfds[u].fd==-1) {
                    break;
                }
            }
            if (u<jobs) {

                PyObject* comp = PyList_GetItem(comps,comp_index);
                const char* bin = PyString_get_c_str(PyTuple_GetItem(comp,0));
                const char* cwd = PyString_get_c_str(PyTuple_GetItem(comp,1));
                PyObject* original_args = PyTuple_GetItem(comp,2);
                DBG(0,"@(%s)(%s)[%ld][%ld]{%ld}{%d}\n",
                        bin,cwd,comp_index,PyList_Size(comps),PyList_Size(original_args),job_num);
                //printf("%s\n",REPR(original_args));
                if (PyList_Size(original_args)<=1) {
                    comp_index++;
                    continue;
                }
                if (PySequence_Contains(original_args,Py_BuildValue("s","-M"))>0) {
                    comp_index++;
                    continue;
                }
                PyObject* bargs = PyList_GetSlice(original_args,0,PyList_Size(original_args));
                /* Spawn the process for generating .lst files */
                int match = 0;
                Py_ssize_t i = PySequence_Contains_Prefix(bargs,Py_BuildValue("s","-o"),&match);
                if (i>=0) {
                    PySequence_DelItem(bargs, i);
                    if (match) {
                        PySequence_DelItem(bargs, i);
                    }
                }
                if (!PySequence_Contains(bargs,Py_BuildValue("s","--list"))) {
                    PyList_Append(bargs,Py_BuildValue("s","--list"));
                }
                if ((!PySequence_Contains(bargs,Py_BuildValue("s","-P"))) && (!PySequence_Contains(bargs,Py_BuildValue("s","-E")))) {
                    PyList_Append(bargs,Py_BuildValue("s","-P"));
                }
                i = PySequence_Contains_Prefix(bargs,Py_BuildValue("s","--list_dir"),&match);
                char tmpname[] = "/tmp/ARMCC/armcc-tmp.XXXXXX";
                char *tmp_dirname = mkdtemp (tmpname);
                if (tmp_dirname) {
                    char lstdname[11+28];
                    snprintf(lstdname,39,"--list_dir=%s",tmp_dirname);
                    if (i>=0) {
                        PySequence_DelItem(bargs, i);
                        if (match) {
                            PySequence_DelItem(bargs, i);
                        }
                    }
                    PyList_Append(bargs,Py_BuildValue("s",lstdname));
                }
                PyList_SetItem(bargs,0,Py_BuildValue("s",bin));
                int pid = run_child(bin,cwd,bargs,&pfds[u].fd,0);
                DBG(0,"$(%d)\n",pid);
                DBG(self->debug_compilations,"# OR. [%d] %s@%s [%s]\n\n",pid,cwd,bin,STRJOIN(original_args));
                DBG(self->debug_compilations,"# EX. [%d] %s@%s [%s]\n\n",pid,cwd,bin,STRJOIN(bargs));
                Py_DecRef(bargs);
                if (pid>0) {
                    DBG(self->debug_compilations, " *** %d created [%s](lst)\n",pid,bin);
                    pfds[u].events = POLLIN|POLLHUP;
                    pjob[u].index = comp_index;
                    pjob[u].pid = pid;
                    buffer_clear(&pjob[u].buff);
                    pjob[u].pfd = &pfds[u];
                    pjob[u].comp = comp;
                    pjob[u].input = 0;
                    pjob[u].fns = Py_BuildValue("s",tmpname);
                    job_num++;
                }
                else {
                    DBG(self->debug_compilations, " *** Failed to create child: [%s](lst): %d\n",bin,errno);
                }
                comp_index++;
            }
        }

    } /* main loop */
    DBG(PRINT_PROGRESS,"\n");

done:
    for (u=0; u<initial_job_num; ++u) {
        buffer_destroy(&pjob[u].buff);
    }

    free(pjob);
    free(pfds);

    return argv;
}
