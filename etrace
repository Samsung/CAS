#!/bin/bash

# Run syscalls tracing of a given command
# Usage:
# etrace COMMAND ...

print_usage () {
    echo "Usage: etrace [-hlimte] [-w WORK_DIR] [--] COMMAND ..."
}

echo_err () {
    echo "[!] $1"
}

if [ "$#" -lt 1 ]; then
    print_usage
    exit 1
fi

# -------- parse args
SAVE_KERNEL_LOG=
WORK_DIR=$(pwd)
INITCWD=$(pwd)
MODULE_PARAMS=""

while getopts "hilmtefsw:c:" opt; do
    case "$opt" in
    h)
        print_usage
        exit 0
        ;;
    l)
        SAVE_KERNEL_LOG=y
        ;;
    f)
        FORCED=y
        ;;
    s)
        MULTI_CATI=y
        ;;
    w)
        WORK_DIR="$OPTARG"
        mkdir -p "$WORK_DIR"
        ;;
    c)
        CORE_RANGE="-c $OPTARG"
        ;;
    i)
        MODULE_PARAMS="$MODULE_PARAMS ignore_repeated_opens=1"
        ;;
    t)
        MODULE_PARAMS="$MODULE_PARAMS trace_thread_names=1"
        ;;
    m)
        MODULE_PARAMS="$MODULE_PARAMS enable_mount=1"
        ;;
    e)
        MODULE_PARAMS="$MODULE_PARAMS trace_env_vars=1"
        ;;
    esac
done

# Remove script's arguments so that "$@" contains the command to run
# under tracer
shift $((OPTIND-1))
# If arguments were separated from the command by "--", remove it too
[ "${1:-}" = "--" ] && shift

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
NPROC=$(nproc)
NPROC=$(expr $NPROC - 1)

if [ -n "${CORE_RANGE}" ]; then
    MAX_JOB_CORE=`echo ${CORE_RANGE} | grep -Po "\d+$"`
    if [ $NPROC -eq $MAX_JOB_CORE ] ; then
        #CORE RANGE is set to max cpu num - cati won't get designated core
        CATI_TASKSET=""
    else 
        CATI_START_IDX=$(expr $MAX_JOB_CORE + 1)
        CATI_TASKSET="taskset -c ${CATI_START_IDX} "
    fi
fi

cat_proc_pid=$(pgrep "cati")
if [ -n "${cat_proc_pid}" ]; then
    if [ -n "${FORCED}" ]; then
        for c_pid in $(pgrep "cati"); do
            kill -9 ${c_pid}
            wait ${c_pid} 2>/dev/null
        done
    else
        echo "ERROR: cat on trace_pipe already running! exiting..."
        echo "Hint - etrace can be forced using -f arg"
        exit 2
    fi
fi

# -------- setting up ftrace
if (( $EUID != 0 )); then
    sudo -n setup_etrace.sh -f $CORE_RANGE
else
    setup_etrace.sh -f
fi
if [ "$?" -ne 0 ]; then
    echo_err "setup_etrace.sh -f failed"
    exit 1
fi

# -------- save our CWD
echo "INITCWD=$INITCWD" > "$WORK_DIR/.nfsdb"

# -------- set up event listener

if [ -n "${CORE_RANGE}" ] && [ "${MULTI_CATI}" == "y" ];  then
    CATI_RANGE=$(seq ${CATI_START_IDX} ${NPROC})
    CATI_JOBS=$(expr $(nproc) - ${CATI_START_IDX})
    mkdir -p ${WORK_DIR}/.nfsdb_parts/
    for i in $(seq 0 ${NPROC}); do
        CATI_CORE=$(expr $(nproc) - $(expr ${i} % ${CATI_JOBS}) - 1)
        taskset -c ${CATI_CORE} ${DIR}/cati /sys/kernel/debug/tracing/per_cpu/cpu${i}/trace_pipe > ${WORK_DIR}/.nfsdb_parts/.nfsdb_part_${i} &
    done
else
    TRACING_CMD="${CATI_TASKSET}${DIR}/cati /sys/kernel/debug/tracing/trace_pipe"
    ${TRACING_CMD} >> "$WORK_DIR/.nfsdb" &
fi

# -------- boost tracer priority
for LISTENER_PID in $(pgrep "cati"); do
    if (( $EUID != 0 )); then
        sudo -n renice -n -18 -p $LISTENER_PID >/dev/null 2>&1
    else
        renice -n -18 -p $LISTENER_PID >/dev/null 2>&1
    fi
done

# -------- save kernel log
if [ "$SAVE_KERNEL_LOG" = "y" ]; then
    dmesg -w > "$WORK_DIR/.nfsdb.klog" &
    KLOGGER_PID="$!"
fi

# -------- install bas_tracer module
MYPID="$$"
if (( $EUID != 0 )); then
    sudo -n setup_etrace.sh -i $MYPID $MODULE_PARAMS
else
    setup_etrace.sh -i $MYPID $MODULE_PARAMS
fi
if [ "$?" -ne 0 ]; then
    echo_err "setup_etrace.sh -i failed"
    exit 1
fi

# -------- run the command
if [ -n "${CORE_RANGE}" ]; then
    taskset ${CORE_RANGE} "$@"
else
    "$@"
fi

RV="$?"

# -------- remove bas_tracer module
if (( $EUID != 0 )); then
    sudo -n setup_etrace.sh -r
else
    setup_etrace.sh -r
fi
if [ "$?" -ne 0 ]; then
    echo_err "setup_etrace.sh -r failed"
    exit 1
fi

# Save stat information to see if any events have been missing
rm -f "$WORK_DIR/.nfsdb.stats" && touch "$WORK_DIR/.nfsdb.stats"
for i in `seq 0 $NPROC`; do
    echo "##---------- CPU $i ---------- ##" >> "$WORK_DIR/.nfsdb.stats"
    cat "/sys/kernel/debug/tracing/per_cpu/cpu$i/stats" >> "$WORK_DIR/.nfsdb.stats"
done

function completion_check () {
    if [ -f "${1}" ]; then
        PREV_LINE=`tail -n 1 ${1}`
        sleep 1
        CURR_LINE=`tail -n 1 ${1}`
        while [ "${PREV_LINE}" != "${CURR_LINE}" ]; do
            PREV_LINE=${CURR_LINE}
            sleep 1
            CURR_LINE=`tail -n 1 ${1}`
        done
    fi
}
export -f completion_check # required for parallel

# -------- check if event listener finished work
if [ -n "${CORE_RANGE}" ] && [ "${MULTI_CATI}" == "y" ];  then
    seq 0 $NPROC | parallel completion_check "${WORK_DIR}/.nfsdb_parts/.nfsdb_part_{}"
else
    completion_check "${WORK_DIR}/.nfsdb"
fi
# -------- stop event listener
for c_pid in $(pgrep "cati"); do
    kill -9 ${c_pid}
    wait ${c_pid} 2>/dev/null
done

# -------- stop kernel logger
if [ "$SAVE_KERNEL_LOG" = "y" ]; then
    kill -SIGINT "${KLOGGER_PID}"
fi

# We're done here
exit $RV
